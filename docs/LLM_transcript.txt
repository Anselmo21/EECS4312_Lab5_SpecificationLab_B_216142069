## Student Name: Rafael Dolores
## Student ID: 216142069

Prompt 1: "I have the following task. Say yes if you understand:
You are asked to implement a Python function that determines whether a set of resource requests can be satisfied given limited capacity. The function takes as input a list of requests and available resources and returns whether a valid allocation exists. The goal is to determine feasibility of allocation based o the provided information. You may assume inputs are provided in a reasonable and consistent format."

LLM Response 1: "Yes."
--------------------------------------------------
Prompt 2: "Please implement the following 
# Student Name: # Student ID: 
""" Stub file for the is allocation feasible exercise. Implement the function is_allocation_feasible to Determine whether a set of resource requests can be satisfied given limited capacities. Take int account any possible constraints. See the lab handout for full requirements. """ 

from typing import Dict, List, Union Number = Union[int, float] 

def is_allocation_feasible( resources: Dict[str, Number], requests: List[Dict[str, Number]] ) -> bool: 
""" Determine whether a set of resource requests can be satisfied given limited capacities. Args: resources : Dict[str, Number], Mapping from resource name to total available capacity. requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required. Returns: True if the allocation is feasible, False otherwise. 
""" 
# TODO: Implement this function raise NotImplementedError( "suggest_slots function has not been implemented yet") "
LLM Response 2: "# Student Name:
# Student ID:

"""
Stub file for the is allocation feasible exercise.

Implement the function `is_allocation_feasible` to determine whether a set of resource requests can be satisfied
given limited capacities.

Assumptions (reasonable/consistent format):
- `resources` maps resource names to non-negative numeric capacities.
- Each request is a dict mapping resource names to numeric required amounts.
- Requests are interpreted as *simultaneous* (i.e., total demand per resource is the sum across all requests).
- Any resource not present in `resources` has capacity 0 (so any positive request for it makes allocation infeasible).
"""

from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping
                   from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.
    """
    # Basic validation: capacities must be numeric and non-negative
    for rname, cap in resources.items():
        if not isinstance(cap, (int, float)):
            return False
        if cap < 0:
            return False

    # Aggregate total demand per resource across all requests
    total_demand: Dict[str, float] = {}

    for req in requests:
        if not isinstance(req, dict):
            return False

        for rname, amount in req.items():
            if not isinstance(amount, (int, float)):
                return False

            # Negative demand doesn't make sense in this context; treat as invalid / infeasible
            if amount < 0:
                return False

            total_demand[rname] = total_demand.get(rname, 0.0) + float(amount)

    # Check feasibility: demand must not exceed capacity for any resource
    for rname, demand in total_demand.items():
        cap = resources.get(rname, 0.0)  # missing resource => 0 capacity
        if demand > float(cap):
            return False

    return True"
--------------------------------------------------
Prompt 3: "That's good implementation, but some tests failed ======================================================== FAILURES ========================================================= ______________________________________________ test_non_dict_request_raises _______________________________________________ def test_non_dict_request_raises(): # Non-Dict Request Raises Error # Constraint: structural validation # Reason: request must be a dict resources = {'cpu': 5} requests = [{'cpu': 2}, ['mem', 1]] # malformed request > with pytest.raises(ValueError): ^^^^^^^^^^^^^^^^^^^^^^^^^ E Failed: DID NOT RAISE <class 'ValueError'> tests/test_solution.py:49: Failed ================================================= short test summary info ================================================= FAILED tests/test_solution.py::test_non_dict_request_raises - Failed: DID NOT RAISE <class 'ValueError'> =============================================== 1 failed, 3 passed in 0.02s =============================================== rafaeldolores@SB-27TZ2J3 EECS4312_Lab5_SpecificationLab_B_216142069 % clear rafaeldolores@SB-27TZ2J3 EECS4312_Lab5_SpecificationLab_B_216142069 % PYTHONPATH=src pytest -v =================================================== test session starts =================================================== platform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0 -- /opt/homebrew/Cellar/pytest/9.0.2/libexec/bin/python cachedir: .pytest_cache rootdir: /Users/rafaeldolores/Desktop/Elmira Survey/EECS4312_Lab5_SpecificationLab_B_216142069 collected 4 items tests/test_solution.py::test_basic_feasible_single_resource PASSED [ 25%] tests/test_solution.py::test_multi_resource_infeasible_one_overloaded PASSED [ 50%] tests/test_solution.py::test_missing_resource_in_availability PASSED [ 75%] tests/test_solution.py::test_non_dict_request_raises FAILED [100%] ======================================================== FAILURES ========================================================= ______________________________________________ test_non_dict_request_raises _______________________________________________ def test_non_dict_request_raises(): # Non-Dict Request Raises Error # Constraint: structural validation # Reason: request must be a dict resources = {'cpu': 5} requests = [{'cpu': 2}, ['mem', 1]] # malformed request > with pytest.raises(ValueError): ^^^^^^^^^^^^^^^^^^^^^^^^^ E Failed: DID NOT RAISE <class 'ValueError'> tests/test_solution.py:49: Failed ================================================= short test summary info ================================================= FAILED tests/test_solution.py::test_non_dict_request_raises - Failed: DID NOT RAISE <class 'ValueError'> =============================================== 1 failed, 3 passed in 0.02s =============================================== rafaeldolores@SB-27TZ2J3 EECS4312_Lab5_SpecificationLab_B_216142069 %"

LLM Response 3: "from typing import Dict, List, Union

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Raises:
        ValueError: if inputs are structurally invalid (e.g., a request is not a dict).
    """
    # Structural validation for resources
    if not isinstance(resources, dict):
        raise ValueError("resources must be a dict mapping resource name to capacity")

    for rname, cap in resources.items():
        if not isinstance(rname, str):
            raise ValueError("resource names must be strings")
        if not isinstance(cap, (int, float)):
            raise ValueError(f"capacity for resource '{rname}' must be numeric")
        if cap < 0:
            raise ValueError(f"capacity for resource '{rname}' cannot be negative")

    # Structural validation for requests
    if not isinstance(requests, list):
        raise ValueError("requests must be a list of dicts")

    total_demand: Dict[str, float] = {}

    for idx, req in enumerate(requests):
        if not isinstance(req, dict):
            raise ValueError(f"request at index {idx} must be a dict")

        for rname, amount in req.items():
            if not isinstance(rname, str):
                raise ValueError("requested resource names must be strings")
            if not isinstance(amount, (int, float)):
                raise ValueError(f"amount for resource '{rname}' in request {idx} must be numeric")
            if amount < 0:
                raise ValueError(f"amount for resource '{rname}' in request {idx} cannot be negative")

            total_demand[rname] = total_demand.get(rname, 0.0) + float(amount)

    # Feasibility check (missing resource => 0 capacity)
    for rname, demand in total_demand.items():
        cap = float(resources.get(rname, 0.0))
        if demand > cap:
            return False

    return True"
--------------------------------------------------
Prompt 4: "Now these are the tests I currently have ## Student Name: ## Student ID: """ Public test suite for the meeting slot suggestion exercise. Students can run these tests locally to check basic correctness of their implementation. The hidden test suite used for grading contains additional edge cases and will not be available to students. """ from solution import is_allocation_feasible import pytest def test_basic_feasible_single_resource(): # Basic Feasible Single-Resource # Constraint: total demand <= capacity # Reason: check basic functional requirement resources = {'cpu': 10} requests = [{'cpu': 3}, {'cpu': 4}, {'cpu': 3}] assert is_allocation_feasible(resources, requests) is True def test_multi_resource_infeasible_one_overloaded(): # Multi-Resource Infeasible (one overload) # Constraint: one resource exceeds capacity # Reason: check detection of per-resource infeasibility resources = {'cpu': 8, 'mem': 30} requests = [{'cpu': 2, 'mem': 8}, {'cpu': 3, 'mem': 10}, {'cpu': 3, 'mem': 14}] assert is_allocation_feasible(resources, requests) is False def test_missing_resource_in_availability(): # Missing Resource in Requests # Constraint: request references unavailable resource # Reason: allocation must be infeasible resources = {'cpu': 10} requests = [{'cpu': 2}, {'gpu': 1}] assert is_allocation_feasible(resources, requests) is False def test_non_dict_request_raises(): # Non-Dict Request Raises Error # Constraint: structural validation # Reason: request must be a dict resources = {'cpu': 5} requests = [{'cpu': 2}, ['mem', 1]] # malformed request with pytest.raises(ValueError): is_allocation_feasible(resources, requests) """TODO: Add at least 5 additional test cases to test your implementation.""" Say yes if you understand"

LLM Response 4: "Yes" 
--------------------------------------------------
Prompt 5: "Can you please add at least 5 additional test cases to test your implementation that will test something unique that my test cases haven't covered yet"

LLM Response 5: "def test_empty_requests_feasible():
    # Empty Requests
    # Constraint: no demand should always be feasible (given valid resources)
    # Reason: baseline/edge case
    resources = {'cpu': 5, 'mem': 10}
    requests = []
    assert is_allocation_feasible(resources, requests) is True


def test_zero_amounts_feasible():
    # Zero Amount Requests
    # Constraint: zero demand should not consume capacity
    # Reason: ensure zero values are handled correctly
    resources = {'cpu': 2}
    requests = [{'cpu': 0}, {'cpu': 0}]
    assert is_allocation_feasible(resources, requests) is True


def test_negative_request_amount_raises():
    # Negative Amount Raises Error
    # Constraint: request amounts must be non-negative
    # Reason: structural/semantic validation
    resources = {'cpu': 10}
    requests = [{'cpu': -1}]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_negative_resource_capacity_raises():
    # Negative Capacity Raises Error
    # Constraint: capacities must be non-negative
    # Reason: structural validation
    resources = {'cpu': -5}
    requests = [{'cpu': 1}]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_non_numeric_capacity_raises():
    # Non-numeric Capacity Raises Error
    # Constraint: capacities must be int/float
    # Reason: type validation for resources
    resources = {'cpu': "10"}  # invalid type
    requests = [{'cpu': 1}]
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_non_numeric_request_amount_raises():
    # Non-numeric Request Amount Raises Error
    # Constraint: request amounts must be int/float
    # Reason: type validation for requests
    resources = {'cpu': 10}
    requests = [{'cpu': "2"}]  # invalid type
    with pytest.raises(ValueError):
        is_allocation_feasible(resources, requests)


def test_request_equals_capacity_feasible():
    # Exact Capacity Boundary
    # Constraint: total demand == capacity should be feasible
    # Reason: off-by-one / boundary check
    resources = {'cpu': 6}
    requests = [{'cpu': 2}, {'cpu': 4}]
    assert is_allocation_feasible(resources, requests) is True"
